<!DOCTYPE html>
<html>
<head>
	<title>Run And Punch v1</title>
	
	<style type="text/css">
		/*Color Pallete
		#D2AA91
		#4C9C8C
		#3B3457
		#6F6A87
		#693D62*/

		body{
			padding: 0;
			margin: 0;
			font-family: Arial;
		}
		#GameArea{
			height: 100vh;
			width: 90%;
			border: 10px solid #3B3457;
			float: left;
			box-sizing: border-box;
			background-color: #6F6A87;
		}
		#GameInfo{
			height: 100vh;
			width: 10%;
			border: none;
			box-sizing: border-box;
			float: left;
			background-color: #693D62;
			padding: 1em;
			font-size: 1.2em;
		}
		#HP-value{
			font-weight: bold;
			color: red;
		}
		#Score-value{
			font-weight: bold;
			color: yellow;
		}
		#GameOverMess{
			position: absolute;
			top: 0;
			left: 0;
			width: 100vw;
			height: 100vh;
			background-color: rgba(0,0,0,0.5);
			text-align: center;
			padding-top: 30vh;
			font-size: 3em;
			line-height: 2em;
			color: white;
		}

	</style>
</head>
<body>
	<div id="GameArea">
		
	</div>
	<div id="GameInfo">
		<div>
			<span>HP : </span>
			<span id="HP-value"></span>
		</div>
		<div>
			<span>Score : </span>
			<span id="Score-value">0</span>
		</div>
	</div>


	<script type="text/javascript">
		"use strict";
		// Cấu hình game
		var GameArea = document.getElementById('GameArea');
		var config = {
			//turn
			turnToScore : 20,
			scoreToBoostEnemy : 20,

			//map
			border : 10,
			MaxWidth : GameArea.clientWidth,
			MaxHeight : GameArea.clientHeight,

			//player
			player : {
				HP : 20,
				ATK : 3,
				DEF : 1,
				Shield : false
			},

			//enemy
			enemy : {
				type0 : {
					HP : 20,
					ATK : 3,
					DEF : 1,
					Shield : false
				},
				type1 : {
					HP : 20,
					ATK : 3,
					DEF : 1,
					Shield : false
				}
			},


			bullet : {},
			item : {}
		};
		var TotalScore=0;

		console.log(config);

		// Khởi tạo các mảng
		var PlayerArray = new Array();
		var EnemyArray = new Array();

		// Khởi tạo các đối tượng

		// Tạo Class
		class GameInstance{ 	//Đối tượng cơ bản
			constructor(posXValue=0, posYValue=0, widthValue=0, heightValue=0, stepValue=0, dirValue=0, existTimeValue=0, lookValue='#fff'){
				this.posX = posXValue;
				this.posY = posYValue;
				this.widthVal = widthValue;
				this.heightVal = heightValue;
				this.step = stepValue;
				this.direction = dirValue;
				this.existTime = existTimeValue;
				this.look = lookValue;
				this.status = true; //true: tồn tại		//false: bị hủy				

				this.htmlElement = document.createElement('span');
				this.htmlElement.style.position = 'absolute';
				this.htmlElement.style.boxSizing = 'border-box';

				this.htmlElement.style.top = (this.posY+config.border)+'px';
				this.htmlElement.style.left = (this.posX+config.border)+'px';
				this.htmlElement.style.width = this.widthVal+'px';
				this.htmlElement.style.height = this.heightVal+'px';
				this.htmlElement.style.background = this.look;
				GameArea.appendChild(this.htmlElement);

				if (this.existTime>0) { //Đặt thời gian biến mất, nếu tồn tại existTime
					let _self=this;
					setTimeout(function(){_self.die();}, _self.existTime);
				}
			}

			setPosX(value){
				this.posX=value;
				this.htmlElement.style.left = (value+config.border)+'px';
			}
			setPosY(value){
				this.posY=value;
				this.htmlElement.style.top = (value+config.border)+'px';
			}
			setWidth(value){
				this.widthVal=value;
				this.htmlElement.style.width = value+'px';
			}
			setHeight(value){
				this.heightVal=value;
				this.htmlElement.style.height = value+'px';
			}
			setLook(value){
				this.look=value;
				this.htmlElement.style.background = value;				
			}

			die(){
				console.log(this);
				this.status = false;
			}

			move(){
				// console.log(this.direction);
				switch (this.direction) {
					case 1: //up ^
						var newPosY=this.posY-this.step;
						if (newPosY<0) newPosY=0;
						this.setPosY(newPosY);			
						break;
					case 2: //left <
						var newPosX=this.posX-this.step;
						if (newPosX<0) newPosX=0;
						this.setPosX(newPosX);
						break;
					case 3: //down v
						var newPosY=this.posY+this.step;
						var realMax=config.MaxHeight-this.heightVal;
						if (newPosY>realMax) newPosY=realMax;
						this.setPosY(newPosY);
						break;
					case 4: //right >
						var newPosX=this.posX+this.step;
						var realMax=config.MaxWidth-this.widthVal;
						if (newPosX>realMax) newPosX=realMax;
						this.setPosX(newPosX);
						break;	
					default:
						// statements_def
						break;
				}
			}
		};

		class Character extends GameInstance{ 
			constructor(posXValue=0, posYValue=0, widthValue=0, heightValue=0, stepValue=0, dirValue=0, existTimeValue=0, lookValue='#fff',HPValue=1,ATKValue=1,DEFValue=1,SHIELDValue=false){
				super(posXValue, posYValue, widthValue, heightValue, stepValue, dirValue, existTimeValue, lookValue);
				//this.HP = HPValue;
				this.ATK = ATKValue;
				this.DEF = DEFValue;
				this.SHIELD = SHIELDValue;
				this.setSHIELD(SHIELDValue);
				this.setHP(HPValue);
			}

			setHP(value){
				this.HP=value;
				if (value<=0) {
					this.die();
				}
			}

			setSHIELD(value){
				this.SHIELD=value;
				if (value==true) {
					//this.htmlElement.style.boxShadow = '0 0 10px white';
					this.htmlElement.style.border = '10px solid white';
				}else{
					//this.htmlElement.style.boxShadow = 'none';
					this.htmlElement.style.border = 'none';
				}
			}

			// Effect
			beAttacked(opp_ATK,opp_force=true){				
				this.setHP(this.HP-opp_ATK);
				this.htmlElement.style.opacity = '0.5';
				let _self=this;
				setTimeout(function(){_self.htmlElement.style.opacity='1';}, 30);

				if (opp_force) {
					let oldDirection = this.direction;
					let oldStep = this.step;
					//this.direction = 
				}
			}
		}

		class Player extends Character{
			constructor(posXValue=0, posYValue=0, widthValue=0, heightValue=0, stepValue=0, dirValue=0, existTimeValue=0, lookValue='#fff',HPValue=1,ATKValue=1,DEFValue=1,SHIELDValue=false){
				super(posXValue, posYValue, widthValue, heightValue, stepValue, dirValue, existTimeValue, lookValue, HPValue, ATKValue, DEFValue, SHIELDValue);
			}

			setHP(value){
				super.setHP(value);		
				document.getElementById('HP-value').innerHTML=value;
			}
		}

		// Danh sách các loại enemy
		class Enemy extends Character{
			constructor(posXValue=0, posYValue=0, widthValue=0, heightValue=0, stepValue=0, dirValue=0, existTimeValue=0, lookValue='#fff',HPValue=1,ATKValue=1,DEFValue=1,SHIELDValue=false,typeEnemyValue=0){
				super(posXValue, posYValue, widthValue, heightValue, stepValue, dirValue, existTimeValue, lookValue, HPValue, ATKValue, DEFValue, SHIELDValue);
				this.typeEnemy=typeEnemyValue;
			}
			huntPlayer(player){
				let xP=player.posX+player.widthVal/2;
				let yP=player.posY+player.heightVal/2;

				let xE=this.posX+this.widthVal/2;
				let yE=this.posY+this.heightVal/2;

				let dX=Math.abs(xE-xP);
				let dY=Math.abs(yE-yP);

				if (dY>=dX) {
					if (yE>=yP) return 1;
					if (yE<yP) return 3;
				}else{
					if (xE>=xP) return 2;
					if (xE<xP) return 4;
				}
			}
		}
		
		
		//PlayerArray.push(new Player(300,200,15,15,5,null,0,'white',20,1,1,false));
		PlayerArray.push(new Player(500,500,15,15,10,null,0,'white',20,5,1,false));
		//PlayerArray.push(new Player(100,500,15,15,10,null,0,'white',20,1,1,false));
		for(let i = 0; i < 5; i++){
			let tmp_step=i+3;
			EnemyArray.push(new Enemy(0,0,20,20,tmp_step,null,0,'red',10,1,1,false));
			EnemyArray.push(new Enemy(config.MaxWidth-20,0,20,20,tmp_step,null,0,'red',10,1,1,false));
			EnemyArray.push(new Enemy(0,config.MaxHeight-20,20,20,tmp_step,null,0,'red',10,1,1,false));
			EnemyArray.push(new Enemy(config.MaxWidth-20,config.MaxHeight-20,20,20,tmp_step,null,0,'red',10,1,1,false));
		}		
		EnemyArray.push(new Enemy(300,300,20,20,5,null,0,'pink',10,1,1,false,1));
		EnemyArray.push(new Enemy(100,100,20,20,5,null,0,'pink',10,1,1,false,1));
		
		var TurnCount=0;
		// 1 turn. Vòng lặp 20/1000 giây sẽ chạy 1 lần
		var turnInterval = setInterval(function(){
			// Xử lý tương tác
			let CountPlayer=PlayerArray.length;
			let CountEnemy=EnemyArray.length;

			// console.log(CountPlayer);
			// console.log(CountEnemy);
			
			// Xét va chạm giữa các đối tượng người chơi. 
				//Quân mình đâm vào nhau cũng chết

			// if (CountPlayer>1) { 	//Nếu có nhiều hơn 1 đối tượng người chơi thì mới xét
			// 	for(let i = 0; i < CountPlayer-1; i++){
			// 		for(let j = i+1; j < CountPlayer; j++){
			// 			// code
			// 		}
			// 	}
			// }

			// Xét va chạm giữa các Enemy
				// Quân địch đâm nhau cũng bị chết

			// if (CountEnemy>1) { 	//Nếu có nhiều hơn 1 đối tượng thì mới xét
			// 	for(let i = 0; i < CountEnemy-1; i++){
			// 		for(let j = i+1; j < CountEnemy; j++){
			// 			// code
			// 		}
			// 	}
			// }

			//Xét va chạm giữa Player và Enemy
			for(let i = 0; i < CountPlayer; i++){
				for(let j = 0; j < CountEnemy; j++){
					let player = PlayerArray[i];
					let enemy = EnemyArray[j];
					if (checkCollision(player,enemy)) {
						player.setHP(player.HP-enemy.ATK);
						enemy.setHP(enemy.HP-player.ATK);
					}
				}
			}
				
			//----------------------------------
			// Xử lý di chuyển		
			for(let i = 0; i < CountPlayer; i++){
				PlayerArray[i].move();
			}	
			for(let i = 0; i < CountEnemy; i++){
				let obj=EnemyArray[i];
				if (obj.typeEnemy==1) {
					obj.direction=obj.huntPlayer(PlayerArray[0]);
				}else{
					if (TurnCount%10==0) 
						obj.direction = Math.floor(Math.random()*4)+1;
				}
				obj.move();
			}

			//----------------------------------
			// Xử lý Item xuất hiện

			//----------------------------------
			// Xử lý các vấn đề khác

			// Xóa đối tượng đã chết
			for(let i in PlayerArray){
				let player=PlayerArray[i]
				if (!(player.status)) {//không còn tồn tại, xóa luôn
					GameArea.removeChild(player.htmlElement);
					PlayerArray.splice(i, 1);					
				}
			}

			if (PlayerArray.length==0) {
				GameOver();
			}

			for (let i in EnemyArray){
				let enemy=EnemyArray[i];
				//console.log(EnemyArray[i]);
				if (!(enemy.status)) {//không còn tồn tại, xóa luôn	
					GameArea.removeChild(enemy.htmlElement);
					EnemyArray.splice(i, 1);
				}
			}

			//Biến đếm
			if (TurnCount%config.turnToScore==0){
				// Sau vài turn tăng 1 điểm
				TotalScore++;
				document.getElementById('Score-value').innerHTML=TotalScore;

				// Cứ sau 1 lượng điểm, tăng tốc độ của Enemy lên 1px
				CountEnemy=EnemyArray.length;
				if (TotalScore%config.scoreToBoostEnemy==0) {
					for (let i = 0; i < CountEnemy; i++){
						EnemyArray[i].step++;
					}
				}
			}

			if (TurnCount==1000) TurnCount=0;
			TurnCount++;
		},20) // 20 tương đương 50FPS

		// Sự kiện khi gõ phím
		window.addEventListener('keypress', function(event){
			//console.log(event.charCode);	
			//console.log(testPlayer.direction);		
			let CountPlayer=PlayerArray.length;
			switch (event.charCode) {
				case 119: 	//w
				case 87: 	//W
				case 38: 	//arrow up
					for(let i = 0; i < CountPlayer; i++){
						PlayerArray[i].direction = 1;
					}	
					break;
				case 97: 	//a
				case 65: 	//A
				case 37: 	//left arrow
					for(let i = 0; i < CountPlayer; i++){
						PlayerArray[i].direction = 2;
					}
					break;
				case 115: 	//s
				case 83: 	//S
				case 40: 	//arrow down
					for(let i = 0; i < CountPlayer; i++){
						PlayerArray[i].direction = 3;
					}
					break;
				case 100: 	//d
				case 68: 	//D
				case 39: 	//arrow right
					for(let i = 0; i < CountPlayer; i++){
						PlayerArray[i].direction = 4;
					}
					break;
				case 32: 	//space   dừng
					for(let i = 0; i < CountPlayer; i++){
						PlayerArray[i].direction = 5;
					}
					break;	
				case 102: 	//f
				case 70: 	//F					
					// for(let i in PlayerArray){
					// 	let playerObj=PlayerArray[i];
					// 	playerObj.setSHIELD(!playerObj.SHIELD);
					// 	playerObj.setHP(playerObj.HP-1);
					// }
					console.log(PlayerArray);
					console.log(EnemyArray);
					break;
				case 81: 	//Q
				case 113: 	//q
					for(let i = 0; i < CountPlayer; i++){
						let playerObj=PlayerArray[i];
						// var originStep=playerObj.step;
						playerObj.step*=2;
						setTimeout(function(){playerObj.step/=2;}, 500);
					}					
					break;
				case 112: 	//p
				case 80: 	//P
					GameOver();
					break;
				default:
					// statements_def
					break;
			}			
		});

		// Danh sách effect khi ăn item

		// Danh sách hiệu ứng

		// Các hàm khác
		function checkCollision(obj1,obj2){ //Hàm kiểm tra 2 GameInstance có va chạm nhau ?
			if ( (obj1.posX>(obj2.posX+obj2.widthVal)) || ((obj1.posX+obj1.widthVal)<obj2.posX) || (obj1.posY>(obj2.posY+obj2.heightVal)) || ((obj1.posY+obj1.heightVal)<obj2.posY) ){
				return false;
			}
			else{
				return true;
			}
		}

		function GameOver(){
			clearInterval(turnInterval);
			var messGameOver=document.createElement('div');
			messGameOver.setAttribute("id","GameOverMess");
			document.getElementsByTagName('body')[0].appendChild(messGameOver);
			messGameOver.innerHTML="Game Over<br>Score : <b>"+TotalScore+"</b>";
		}

		function calculateHP(player,enemy){

		}
	</script>
</body>
</html>